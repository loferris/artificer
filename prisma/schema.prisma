generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String?  @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  projects Project[]
  apiKeys  ApiKey[]

  @@map("users")
}

model ApiKey {
  id          String    @id @default(cuid())
  userId      String
  name        String    // Descriptive name (e.g., "LibreChat Production", "CLI Access")
  keyHash     String    @unique // Hashed API key (never store plaintext)
  lastUsedAt  DateTime?
  expiresAt   DateTime?
  createdAt   DateTime  @default(now())

  // IP whitelist for this specific key (optional, overrides global whitelist)
  ipWhitelist String[]  @default([])

  // Permissions/scopes (future: fine-grained access control)
  scopes      String[]  @default(["*"]) // "*" = full access

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("api_keys")
  @@index([userId])
  @@index([keyHash])
}

model Project {
  id          String   @id @default(cuid())
  name        String
  description String?
  userId      String?
  settings    Json?    // Custom instructions, model preferences, etc.
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user             User?             @relation(fields: [userId], references: [id], onDelete: SetNull)
  conversations    Conversation[]
  documents        Document[]
  knowledgeEntities KnowledgeEntity[]

  @@map("projects")
  @@index([userId])
}

model Conversation {
  id        String   @id @default(cuid())
  title     String?
  model     String   // claude-3-5-sonnet, deepseek-coder, etc.
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Project association (optional - conversations can exist without projects)
  projectId String?
  project   Project? @relation(fields: [projectId], references: [id], onDelete: SetNull)

  messages  Message[]
  summaries ConversationSummary[]
  artifacts Artifact[]
  documents Document[]

  // Conversation settings
  systemPrompt String?
  temperature  Float?
  maxTokens    Int?

  @@map("conversations")
}

model Message {
  id        String   @id @default(cuid())
  role      String   // "user", "assistant", "system"
  content   String
  tokens    Int?     // token count for cost tracking
  createdAt DateTime @default(now())

  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // Future: message branching support
  parentId String?
  parent   Message? @relation("MessageTree", fields: [parentId], references: [id])
  children Message[] @relation("MessageTree")

  // Artifacts created in this message
  artifacts Artifact[]
  documents Document[]

  @@map("messages")
}

model Document {
  id          String   @id @default(cuid())

  // Core content
  type        String   @default("text") // "code", "markdown", "mermaid", "html", "svg", "json", "yaml", "text", "csv"
  content     String   // Document/artifact content
  filename    String
  title       String?  // Display title
  description String?  // Brief description

  // For code artifacts
  language       String?  // Programming language
  fileExtension  String?  // e.g., "ts", "md", "svg"

  // Legacy fields (for backward compatibility with uploaded files)
  originalName String?  // Keep original filename for display
  contentType  String   @default("text/plain") // MIME type
  size         Int      @default(0) // File size in bytes

  // Source tracking
  source      String   @default("uploaded") // "uploaded", "generated", "updated", "manual"

  // Associations (all optional for flexibility)
  projectId      String?
  project        Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)

  conversationId String?
  conversation   Conversation? @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  messageId      String?
  message        Message? @relation(fields: [messageId], references: [id], onDelete: SetNull)

  // RAG/Search control
  indexed     Boolean  @default(true)  // Include in RAG search?
  embedding   Float[]  @default([])    // Vector embedding (empty if not indexed)

  // Versioning
  version     Int      @default(1)
  versions    DocumentVersion[]

  // Additional metadata
  metadata    Json?

  // Timestamps
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  uploadedAt  DateTime @default(now()) // Legacy, same as createdAt

  @@map("documents")
  @@index([projectId])
  @@index([conversationId])
  @@index([messageId])
  @@index([type])
  @@index([source])
  @@index([indexed])
  @@index([contentType])
}

model DocumentVersion {
  id                String   @id @default(cuid())
  documentId        String
  document          Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  version           Int      // Version number
  content           String   // Content at this version
  changeDescription String?  // Description of what changed
  createdAt         DateTime @default(now())

  messageId         String?  // Message that created this version

  @@map("document_versions")
  @@index([documentId])
  @@index([documentId, version])
}

model KnowledgeEntity {
  id           String   @id @default(cuid())
  projectId    String
  type         String   // "character", "location", "concept", etc.
  name         String   // Primary identifier
  data         Json     // Flexible structured data specific to entity type
  embedding    Float[]  // Vector embedding for semantic search
  sourceType   String   // "conversation", "document", "manual"
  sourceId     String?  // ID of source (conversationId, documentId, etc.)
  extractedAt  DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@map("knowledge_entities")
  @@index([projectId])
  @@index([type])
  @@index([projectId, type])
}

model ConversationSummary {
  id             String       @id @default(cuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // Summary content
  summaryContent String       // The actual summary text
  messageRange   Json         // { startMessageId, endMessageId, startIndex, endIndex }
  tokensSaved    Int          // Approximate tokens saved by this summary
  messageCount   Int          // Number of messages summarized

  // Versioning and chaining
  createdAt      DateTime     @default(now())
  supersededBy   String?      // ID of the summary that replaced this one (for re-summarization)

  @@map("conversation_summaries")
  @@index([conversationId])
  @@index([conversationId, supersededBy])
}

model RoutingDecision {
  id               String   @id @default(cuid())
  prompt           String   // Original user prompt
  analysis         Json     // Analyzer agent output: complexity, category, capabilities, tokens
  routingPlan      Json     // Router agent output: selected model(s), strategy (single/ensemble/speculative)
  executedModel    String   // The model that was actually used
  validationResult Json?    // Validator agent output: accuracy, completeness, retry decision
  totalCost        Decimal  @db.Decimal(10, 6) // Total cost in USD
  successful       Boolean  // Whether the final response was successful
  retryCount       Int      @default(0) // Number of retries attempted
  conversationId   String?  // Link to conversation if applicable
  createdAt        DateTime @default(now())

  @@map("routing_decisions")
  @@index([conversationId])
  @@index([executedModel])
  @@index([successful])
  @@index([createdAt])
}

model Artifact {
  id             String   @id @default(cuid())
  type           String   // "code", "markdown", "mermaid", "html", "svg", "json", "yaml", etc.
  content        String   // The artifact content
  title          String?
  description    String?
  language       String?  // Programming language for code artifacts
  fileExtension  String?  // e.g., "ts", "md", "svg"
  filename       String?  // Suggested filename
  version        Int      @default(1)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Associations
  conversationId String?
  conversation   Conversation? @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  messageId      String?
  message        Message?      @relation(fields: [messageId], references: [id], onDelete: SetNull)

  // Additional metadata
  metadata       Json?

  // Version history
  versions       ArtifactVersion[]

  @@map("artifacts")
  @@index([conversationId])
  @@index([messageId])
  @@index([type])
  @@index([createdAt])
}

model ArtifactVersion {
  id                String   @id @default(cuid())
  artifactId        String
  artifact          Artifact @relation(fields: [artifactId], references: [id], onDelete: Cascade)

  version           Int      // Version number
  content           String   // Content at this version
  changeDescription String?  // Description of what changed
  createdAt         DateTime @default(now())

  messageId         String?  // Message that created this version

  @@map("artifact_versions")
  @@index([artifactId])
  @@index([artifactId, version])
}
