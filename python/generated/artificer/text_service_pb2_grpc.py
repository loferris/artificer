# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

from artificer import text_service_pb2 as artificer_dot_text__service__pb2

GRPC_GENERATED_VERSION = '1.76.0'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + ' but the generated code in artificer/text_service_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )


class TextServiceStub(object):
    """Text Processing Service
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.ChunkDocument = channel.unary_unary(
                '/artificer.TextService/ChunkDocument',
                request_serializer=artificer_dot_text__service__pb2.ChunkDocumentRequest.SerializeToString,
                response_deserializer=artificer_dot_text__service__pb2.ChunkDocumentResponse.FromString,
                _registered_method=True)
        self.ChunkDocumentsBatch = channel.unary_unary(
                '/artificer.TextService/ChunkDocumentsBatch',
                request_serializer=artificer_dot_text__service__pb2.ChunkDocumentsBatchRequest.SerializeToString,
                response_deserializer=artificer_dot_text__service__pb2.ChunkDocumentsBatchResponse.FromString,
                _registered_method=True)
        self.CountTokens = channel.unary_unary(
                '/artificer.TextService/CountTokens',
                request_serializer=artificer_dot_text__service__pb2.CountTokensRequest.SerializeToString,
                response_deserializer=artificer_dot_text__service__pb2.CountTokensResponse.FromString,
                _registered_method=True)
        self.CountConversationTokens = channel.unary_unary(
                '/artificer.TextService/CountConversationTokens',
                request_serializer=artificer_dot_text__service__pb2.CountConversationTokensRequest.SerializeToString,
                response_deserializer=artificer_dot_text__service__pb2.CountConversationTokensResponse.FromString,
                _registered_method=True)
        self.EstimateMessageFit = channel.unary_unary(
                '/artificer.TextService/EstimateMessageFit',
                request_serializer=artificer_dot_text__service__pb2.EstimateMessageFitRequest.SerializeToString,
                response_deserializer=artificer_dot_text__service__pb2.EstimateMessageFitResponse.FromString,
                _registered_method=True)
        self.CalculateContextWindow = channel.unary_unary(
                '/artificer.TextService/CalculateContextWindow',
                request_serializer=artificer_dot_text__service__pb2.CalculateContextWindowRequest.SerializeToString,
                response_deserializer=artificer_dot_text__service__pb2.CalculateContextWindowResponse.FromString,
                _registered_method=True)


class TextServiceServicer(object):
    """Text Processing Service
    """

    def ChunkDocument(self, request, context):
        """Chunk a document into overlapping segments
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ChunkDocumentsBatch(self, request, context):
        """Chunk multiple documents in batch
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def CountTokens(self, request, context):
        """Count tokens in text
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def CountConversationTokens(self, request, context):
        """Count tokens in conversation with message overhead
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def EstimateMessageFit(self, request, context):
        """Estimate how many messages fit within token budget
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def CalculateContextWindow(self, request, context):
        """Calculate optimal context window configuration
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_TextServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'ChunkDocument': grpc.unary_unary_rpc_method_handler(
                    servicer.ChunkDocument,
                    request_deserializer=artificer_dot_text__service__pb2.ChunkDocumentRequest.FromString,
                    response_serializer=artificer_dot_text__service__pb2.ChunkDocumentResponse.SerializeToString,
            ),
            'ChunkDocumentsBatch': grpc.unary_unary_rpc_method_handler(
                    servicer.ChunkDocumentsBatch,
                    request_deserializer=artificer_dot_text__service__pb2.ChunkDocumentsBatchRequest.FromString,
                    response_serializer=artificer_dot_text__service__pb2.ChunkDocumentsBatchResponse.SerializeToString,
            ),
            'CountTokens': grpc.unary_unary_rpc_method_handler(
                    servicer.CountTokens,
                    request_deserializer=artificer_dot_text__service__pb2.CountTokensRequest.FromString,
                    response_serializer=artificer_dot_text__service__pb2.CountTokensResponse.SerializeToString,
            ),
            'CountConversationTokens': grpc.unary_unary_rpc_method_handler(
                    servicer.CountConversationTokens,
                    request_deserializer=artificer_dot_text__service__pb2.CountConversationTokensRequest.FromString,
                    response_serializer=artificer_dot_text__service__pb2.CountConversationTokensResponse.SerializeToString,
            ),
            'EstimateMessageFit': grpc.unary_unary_rpc_method_handler(
                    servicer.EstimateMessageFit,
                    request_deserializer=artificer_dot_text__service__pb2.EstimateMessageFitRequest.FromString,
                    response_serializer=artificer_dot_text__service__pb2.EstimateMessageFitResponse.SerializeToString,
            ),
            'CalculateContextWindow': grpc.unary_unary_rpc_method_handler(
                    servicer.CalculateContextWindow,
                    request_deserializer=artificer_dot_text__service__pb2.CalculateContextWindowRequest.FromString,
                    response_serializer=artificer_dot_text__service__pb2.CalculateContextWindowResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'artificer.TextService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('artificer.TextService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class TextService(object):
    """Text Processing Service
    """

    @staticmethod
    def ChunkDocument(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/artificer.TextService/ChunkDocument',
            artificer_dot_text__service__pb2.ChunkDocumentRequest.SerializeToString,
            artificer_dot_text__service__pb2.ChunkDocumentResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ChunkDocumentsBatch(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/artificer.TextService/ChunkDocumentsBatch',
            artificer_dot_text__service__pb2.ChunkDocumentsBatchRequest.SerializeToString,
            artificer_dot_text__service__pb2.ChunkDocumentsBatchResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def CountTokens(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/artificer.TextService/CountTokens',
            artificer_dot_text__service__pb2.CountTokensRequest.SerializeToString,
            artificer_dot_text__service__pb2.CountTokensResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def CountConversationTokens(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/artificer.TextService/CountConversationTokens',
            artificer_dot_text__service__pb2.CountConversationTokensRequest.SerializeToString,
            artificer_dot_text__service__pb2.CountConversationTokensResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def EstimateMessageFit(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/artificer.TextService/EstimateMessageFit',
            artificer_dot_text__service__pb2.EstimateMessageFitRequest.SerializeToString,
            artificer_dot_text__service__pb2.EstimateMessageFitResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def CalculateContextWindow(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/artificer.TextService/CalculateContextWindow',
            artificer_dot_text__service__pb2.CalculateContextWindowRequest.SerializeToString,
            artificer_dot_text__service__pb2.CalculateContextWindowResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
